module IRTS.CodegenElixir(codegenElixir) where

import IRTS.CodegenCommon
import IRTS.Simplified
import IRTS.Defunctionalise (DDecl)
import IRTS.Lang

import Idris.Core.TT (Const(..), Name)

import Control.Applicative ((<|>))

import Data.List (intercalate)
import Data.Maybe (fromJust)

import Text.PrettyPrint (Doc, ($$), nest, parens, render, text, vcat)
import Text.Show.Pretty (ppDoc, ppShow)

codegenElixir :: CodeGenerator
codegenElixir ci = writeFile (outputFile ci) (render source)
  where
    source = vcat sections
    sections =
      [ prelude
      , body
      , epilogue
      ]
    prelude = elixirComment "generated by idris-elixir"

    body :: Doc
    body = fromJust $
      simplified (simpleDecls ci) <|>
      defunctionalized (defunDecls ci) <|>
      lambdaLifted (liftDecls ci) <|>
      Just (elixirComment "ERROR: All code generation strategies failed")

    epilogue = elixirComment "EOF (generated by idris-elixir)"

indent :: Doc -> Doc
indent = nest 4

indentMany :: [Doc] -> Doc
indentMany = vcat . map indent

lvar :: LVar -> String
lvar (Loc n) = show n
lvar (Glob name) = show name

idrisConst :: Const -> String
idrisConst c =
  case c of
    I n -> show n
    BI n -> show n
    Fl d -> show d
    Ch x -> show x
    Str s -> "\"" ++ s ++ "\""
    B8 w -> show w              -- may need to simulate types with tagged tuples
    B16 w -> show w
    B32 w -> show w
    B64 w -> show w
    AType _ty -> undefined
    StrType -> undefined
    WorldType -> undefined
    TheWorld -> undefined
    VoidType -> undefined
    Forgot -> undefined

idrisPrimFn :: PrimFn -> String
idrisPrimFn fn =
  case fn of
    LPlus _ -> "Kernel.+"
    LMinus _ -> "Kernel.-"
    LTimes _ -> "Kernel.*"
    LUDiv _ -> "Kernel.div"
    LSDiv _ -> "Kernel./"
    LURem _ -> "Kernel.rem"
    LSRem _ -> undefined        -- what are the rounding semantics here?
    LAnd _ -> "Bitwise.band"
    LOr _ -> "Bitwise.bor"
    LXOr _ -> "Bitwise.bxor"
    LCompl _ -> "Bitwise.bnot"
    LSHL _ -> "Bitwise.bsl"
    LLSHR _ -> undefined        -- does Elixir support signed machine words?
    LASHR _ -> "Bitwise.bsr"
    LEq _ -> "Kernel.==="
    LLt _ -> "Kernel.<"
    LLe _ -> "Kernel.<="
    LGt _ -> "Kernel.>"
    LGe _ -> "Kernel.>="
    LSLt _ -> "Kernel.<"
    LSLe _ -> "Kernel.<="
    LSGt _ -> "Kernel.>"
    LSGe _ -> "Kernel.>="
    LSExt _ _ -> undefined
    LZExt _ _ -> undefined
    LTrunc _ _ -> undefined
    LStrConcat -> "Kernel.<>"
    LStrLt -> "Kernel.<"
    LStrEq -> "Kernel.==="
    LStrLen -> "String.length"
    LIntFloat _ -> undefined
    LFloatInt _ -> "Kernel.abs"
    LIntStr _ -> "Kernel.inspect"
    LStrInt _ -> "Integer.parse"
    LFloatStr -> "Kernel.inspect"
    LStrFloat -> "Float.parse"
    LChInt _ -> undefined
    LIntCh _ -> "&<<&1>>"
    LBitCast _ _ -> undefined
    LFExp -> ":math.pow"
    LFLog -> ":math.log"        -- what base is this? there's also log10 and log2.
    LFSin -> ":math.sin"        -- is Idris using radians?
    LFCos -> ":math.cos"
    LFTan -> ":math.tan"
    LFASin -> ":math.asign"
    LFACos -> ":math.acos"
    LFATan -> ":math.atan"
    LFSqrt -> ":math.sqrt"
    LFFloor -> "Float.floor"
    LFCeil -> "Float.ceil"
    LFNegate -> "Kernel.-"
    LStrHead -> "String.first"  -- this Elixir fn is grapheme based; is that
                                -- what Idris expects?
    LStrTail -> "&String.slice(&1, 1..-1)"
    LStrCons -> undefined       -- does Idris expect char prepending or string appending?
    LStrIndex -> "String.at"    -- again, Elixir call is grapheme-based
    LStrRev -> "String.reverse"
    LStrSubstr -> "String.slice"
    LReadStr -> "IO.gets(:stdio, \"\")"
    LWriteStr -> "&IO.puts(:stdio, &1)"
    LSystemInfo -> undefined
    LFork -> undefined
    LPar -> undefined
    LExternal name -> "TODO: External '" ++ ppShow name ++ "''"
    LNoOp -> undefined

simplified :: [(Name, SDecl)] -> Maybe Doc
simplified = Just . vcat . map namedSDecl

namedSDecl :: (Name, SDecl) -> Doc
namedSDecl (n, d) = {- text (ppShow n) $$ -} decl d
  where
    decl :: SDecl -> Doc
    decl (SFun fnName names num ex) =
      blank $$ text (ppShow fnName ++ "(" ++ intercalate ", " (map ppShow names) ++ ")") $$
      indentMany
        [ ppDoc num
        , expr ex
        ]

    expr :: SExp -> Doc
    expr (SV var) = text $ lvar var
    expr (SApp bool name vars) = text $ "APP: " ++ intercalate "; " [ppShow bool, ppShow name, ppShow $ map lvar vars]
    expr (SLet var expr1 expr2) = text ("LET: " ++ lvar var) $$
      indentMany
      [ expr expr1
      , expr expr2
      ]
    expr (SUpdate var expr1) = text ("UPDATE: " ++ lvar var) $$ indent (expr expr1)
    expr (SCon maybeVar num name vars) = text "CON:" $$
      indentMany
      [ text $ fromJust $ fmap lvar maybeVar <|> Just "no var"
      , ppDoc num
      , ppDoc name
      , ppDoc $ map lvar vars
      ]
    expr (SCase caseType var alts) = text "CASE:" $$ indentMany
      [ ppDoc caseType
      , text $ lvar var
      , indent $ vcat $ map alt alts
      ]
    expr (SChkCase var alts) = text ("CHK CASE: " ++ lvar var) $$ (indent . vcat) (map alt alts)
    expr (SProj var num) = text $ "PROJ: " ++ lvar var ++ ", " ++ ppShow num
    expr (SConst c) = text $ "CONST: " ++ idrisConst c
    expr (SForeign fdesc1 fdesc2 fdescVarPairs) = text "FOREIGN:" $$ indentMany
      [ ppDoc fdesc1
      , ppDoc fdesc2
      , ppDoc fdescVarPairs
      ]
    expr (SOp primFn vars) = text ("OP: " ++ idrisPrimFn primFn) $$ indent (text $ intercalate ", " (map lvar vars))
    expr SNothing = text "__nothing__"
    expr (SError str) = text $ "ERROR: " ++ str

    alt :: SAlt -> Doc
    alt (SConCase num1 num2 name names expr1) = text "ALT CON CASE:" $$ indentMany
      [ ppDoc num1
      , ppDoc num2
      , ppDoc name
      , parens $ text $ intercalate ", " (map ppShow names)
      , expr expr1
      ]
    alt (SConstCase c expr1) = text "ALT CONST CASE:" $$ indentMany
      [ text $ idrisConst c
      , expr expr1
      ]
    alt (SDefaultCase expr1) = text "ALT DEFAULT CASE:" $$ expr expr1

defunctionalized :: [(Name, DDecl)] -> Maybe Doc
defunctionalized _decls = Nothing

lambdaLifted :: [(Name, LDecl)] -> Maybe Doc
lambdaLifted _decls = Nothing

-- |Emit an Elixir-style comment (line beginning with '#').
-- Doesn't support multiple lines nor line wrapping.
elixirComment :: String -> Doc
elixirComment c = text $ "# " ++ c

blankLines :: Int -> Doc
blankLines n = text $ replicate (n-1) '\n'

blank :: Doc
blank = blankLines 1
