module IRTS.CodegenElixir(codegenElixir) where

import IRTS.CodegenCommon
import IRTS.Simplified
import IRTS.Defunctionalise (DDecl)
import IRTS.Lang

import Idris.Core.TT

import Data.Maybe
import Data.Char

codegenElixir :: CodeGenerator
codegenElixir ci = do
  let out = concatMap doCodegen (simpleDecls ci)
  writeFile (outputFile ci) ("# generated by idris-elixir\n" ++ helpers ++ "\n" ++
                            "defmodule IdrisElixir do\n" ++
                            indent out ++ "\n" ++
                            "end\n" ++
                            start ++ "\n" ++
                            "\n\n")

start = "IdrisElixir." ++ elixirname (sMN 0 "runMain") ++ "()"

helpers = errCode ++ "\n"

errCode = unlines
  [ "defmodule IdrisElixirError do"
  , "  defexception [:message]"
  , ""
  , "  def exception(value) do"
  , "    %IdrisElixirError{message: inspect value}"
  , "  end"
  , "end"
  ]

elixirname :: Name -> String
elixirname n = "idris_" ++ concatMap elixirchar (showCG n)
  where elixirchar x | isAlpha x || isDigit x = [x]
                     | otherwise = "_" ++ show (fromEnum x) ++ "_"

var :: Name -> String
var n = "var" ++ elixirname n

loc :: Int -> String
loc i = "loc" ++ show i

doCodegen :: (Name, SDecl) -> String
doCodegen (n, SFun _ args i def) = cgFun n args def

indent :: String -> String
indent block =
  unlines $ map (\line -> "  " ++ line) (lines block)

cgFun :: Name -> [Name] -> SExp -> String
cgFun n args def
    = "def " ++ elixirname n ++ "("
             ++ showSep ", " (map (loc . fst) (zip [0..] args)) ++ ") do\n"
             ++ indent (cgBody doRet def) ++ "end\n\n"
  where doRet :: String -> String -- Return the calculated expression
        doRet str =  str

-- cgBody converts the SExp into a chunk of php which calculates the result
-- of an expression, then runs the function on the resulting bit of code.
--
-- We do it this way because we might calculate an expression in a deeply nested
-- case statement, or inside a let, etc, so the assignment/return of the calculated
-- expression itself may happen quite deeply.

cgBody :: (String -> String) -> SExp -> String
cgBody ret (SV (Glob n)) = ret $ elixirname n ++ "()"
cgBody ret (SV (Loc i)) = ret $ loc i
cgBody ret (SApp _ f args) = ret $ elixirname f ++ "(" ++
                                   showSep "," (map cgVar args) ++ ")"
cgBody ret (SLet (Loc i) v sc)
   = cgBody (\x -> loc i ++ " = " ++ x ++ "\n") v ++
     cgBody ret sc
cgBody ret (SUpdate n e)
   = cgBody ret e
cgBody ret (SProj e i)
   = ret $ cgVar e ++ "[" ++ show (i + 1) ++ "]"
cgBody ret (SCon _ t n args)
   = ret $ "[" ++ showSep ", "
              (show t : (map cgVar args)) ++ "]"
cgBody ret (SCase _ e alts)
   = let scrvar = cgVar e
         scr = if any conCase alts then "hd " ++ scrvar else scrvar in
       "case " ++ scr ++ " do\n"
         ++ indent (showSep "\n" (map (cgAlt ret scrvar) alts)) ++ "\nend"
  where conCase (SConCase _ _ _ _ _) = True
        conCase _ = False
cgBody ret (SChkCase e alts)
   = let scrvar = cgVar e
         scr = if any conCase alts then "hd " ++ scrvar else scrvar in
       "case " ++ scr ++ " do\n"
         ++ indent (showSep "\n" (map (cgAlt ret scrvar) alts)) ++ "\nend"
  where conCase (SConCase _ _ _ _ _) = True
        conCase _ = False
cgBody ret (SConst c) = ret $ cgConst c
cgBody ret (SOp op args) = ret $ cgOp op (map cgVar args)
cgBody ret SNothing = ret "0"
cgBody ret (SError x) = ret $ "raise IdrisElixirError, " ++ show x
cgBody ret _ = ret $ "raise IdrisElixirError, \"NOT IMPLEMENTED!!!!\""

cgAlt :: (String -> String) -> String -> SAlt -> String
cgAlt ret scr (SConstCase t exp)
   = show t ++ " ->\n" ++ indent (cgBody ret exp)
cgAlt ret scr (SDefaultCase exp) = "_ ->\n" ++ indent (cgBody ret exp)
cgAlt ret scr (SConCase lv t n args exp)
   = show t ++ " ->\n"
             ++ indent (project 1 lv args ++ "\n" ++ cgBody ret exp)
   where project i v [] = ""
         project i v (n : ns) = loc v ++ " = Enum.at(" ++ scr ++ ", " ++ show i ++ "); "
                                  ++ project (i + 1) (v + 1) ns

cgVar :: LVar -> String
cgVar (Loc i) = loc i
cgVar (Glob n) = var n

cgConst :: Const -> String
cgConst (I i) = show i
cgConst (Ch i) = "''" ++ show i ++ "''"
cgConst (BI i) = show i
cgConst (Str s) = show s
cgConst TheWorld = "0"
cgConst x | isTypeConst x = "0"
cgConst x = error $ "Constant " ++ show x ++ " not compilable yet"

cgOp :: PrimFn -> [String] -> String
cgOp (LPlus (ATInt _)) [l, r]
     = "(" ++ l ++ " + " ++ r ++ ")"
cgOp (LMinus (ATInt _)) [l, r]
     = "(" ++ l ++ " - " ++ r ++ ")"
cgOp (LTimes (ATInt _)) [l, r]
     = "(" ++ l ++ " * " ++ r ++ ")"
cgOp (LEq (ATInt _)) [l, r]
     = "(" ++ l ++ " == " ++ r ++ ")"
cgOp (LSLt (ATInt _)) [l, r]
     = "(" ++ l ++ " < " ++ r ++ ")"
cgOp (LSLe (ATInt _)) [l, r]
     = "(" ++ l ++ " <= " ++ r ++ ")"
cgOp (LSGt (ATInt _)) [l, r]
     = "(" ++ l ++ " > " ++ r ++ ")"
cgOp (LSGe (ATInt _)) [l, r]
     = "(" ++ l ++ " >= " ++ r ++ ")"
cgOp LStrEq [l,r] = "(" ++ l ++ " == " ++ r ++ ")"
cgOp LStrRev [x] = "strrev(" ++ x ++ ")"
cgOp LStrLen [x] = "strlen(utf8_decode(" ++ x ++ "))"
cgOp LStrHead [x] = "ord(" ++ x ++ "[0])"
cgOp LStrIndex [x, y] = "ord(" ++ x ++ "[" ++ y ++ "])"
cgOp LStrTail [x] = "substr(" ++ x ++ ", 1)"

cgOp (LIntStr _) [x] = "\"" ++ x ++ "\""
cgOp (LChInt _) [x] = x
cgOp (LIntCh _) [x] = x
cgOp (LSExt _ _) [x] = x
cgOp (LTrunc _ _) [x] = x
cgOp LWriteStr [_,str] = "IO.puts(" ++ str ++ ")"
cgOp LReadStr [_] = "IO.gets(\"\")"
cgOp LStrConcat [l,r] = "(" ++ l ++ " <> " ++ r ++ ")"
cgOp LStrCons [l,r] = "\"#{" ++ l ++ "}{" ++ r ++ "}\""
cgOp (LStrInt _) [x] = x
cgOp op exps = "raise IdrisElixirError, \"OPERATOR " ++ show op ++ " NOT IMPLEMENTED!!!!\""
-- error("Operator " ++ show op ++ " not implemented")
